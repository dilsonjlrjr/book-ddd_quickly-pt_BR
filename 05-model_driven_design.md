# Model-Driven Design
 
Os capítulos anteriores salientaram a importância de uma aproximação do desenvolvimento do software centrado no domínio do negócio. Dissemos que é de fundamental importância criar um modelo que esteja profundamente enraizado no domínio, refletindo os conceitos essenciais do domínio com grande precisão. 

A Linguagem Ubíqua deve ser plenamente exercida durante todo o processo, a fim de facilitar a comunicação entre os especialistas do software e os peritos do domínio, para descobrir os conceitos chaves do domínio que devam ser usados no modelo. A finalidade desse processo é criar um modelo bom. A etapa seguinte é implementar o modelo no código. Esse processo é igualmente importante para o desenvolvimento do software. Ter criado um grande modelo, mas não transferi-lo corretamente para o código acabará criando software de qualidade questionável.

Acontece que os analistas do software trabalham com os peritos do domínio do negócio durante meses, descobrem os elementos fundamentais do domínio, enfatizam os relacionamentos entre eles, criam um modelo correto, que capta com precisão o domínio. Então, o modelo é transferido para os desenvolvedores de software. Os desenvolvedores olham o modelo e descobrem que alguns dos conceitos ou dos relacionamentos encontrados neles não podem corretamente ser expressos no código. Assim, usam o modelo como a fonte original da inspiração, mas eles criam seu próprio design contendo apenas algumas ideias do modelo e adicionam algumas ideias próprias. O processo de desenvolvimento continua e mais classes são adicionadas ao código, expandindo a divisão entre o modelo original e a implementação definitiva. Não temos garantia de resultados satisfatórios. Bons desenvolvedores podem até entregar um produto que funcione, mas será que ele vai resistir ao tempo? Será que ele vai ser facilmente estendido? Será que ele é fácil de dar manutenção?

Qualquer domínio pode ser expresso com muitos modelos, e qualquer modelo pode ser expresso de várias maneiras no código. Para cada problema particular pode haver mais de uma solução. Qual escolha fazer? Ter um modelo analiticamente correto não significa que o modelo pode ser expresso diretamente no código. Talvez a sua execução quebre alguns princípios do design do software, o que não é aconselhável. É importante escolher um modelo que possa ser facilmente e exatamente extraído para o código. Como fazer a abordagem e a transição do modelo para o código?

Uma das técnicas de design recomendadas é chamada de modelo de análise, que é separada do design do código e geralmente é usada por pessoas diferentes. O modelo de análise é o resultado da análise do domínio do negócio, resultando em um modelo que não leva em conta o software a ser implementado. Tal modelo é usado para compreender o domínio. Um determinado nível de conhecimento é construído e o resultado do modelo pode estar analiticamente correto. O software não é levado em consideração nessa fase, uma vez que seja considerado um fator a mais para confusão. Esse modelo afetará os desenvolvedores, que estarão incumbidos de compreender e fazer o design. Uma vez que o modelo não foi construído com princípios de design em mente, ele provavelmente não servirá muito bem a essa finalidade. Os desenvolvedores terão que adaptá-lo ou criar um design separado. E não é fácil fazer essa adaptação entre o design e o código. O resultado é que os modelos de análise são abandonados logo depois que a codificação começa.
 
Uma das principais questões com essa abordagem é que os analistas não podem prever alguns dos defeitos em seu modelo e todas as complexidades do domínio. Os analistas podem ter adentrado em detalhes em alguns componentes do modelo e não detalharam bastante outros. Os detalhes mais importantes são descobertos durante o processo de design e de execução. Um modelo que seja indigno ao domínio poderá vir a ter problemas sérios com os objetos de persistência ou de desempenho inaceitável.
Os desenvolvedores serão obrigados a tomar as próprias decisões, mudando o design a fim resolver um problema real que não foi considerado quando o modelo foi criado. Eles criam um design afastado do modelo, tornando-o menos relevante.

Se os analistas trabalharem independentemente, criarão, eventualmente, um modelo. Quando esse modelo for passado aos designers, alguns dos conhecimentos dos analistas sobre o domínio e o modelo serão perdidos. Mesmo que o modelo possa ser expresso em diagramas e na escrita, ainda há chances de os designers não compreenderem o seu significado, o relacionamento entre seus objetos e seus comportamentos. Existem detalhes do modelo que não são expressos facilmente em um diagrama e não podem inteiramente ser apresentados sequer por escrito. Os desenvolvedores passarão por momentos complicados para esboçar isso. Em alguns casos, farão algumas suposições sobre o comportamento pretendido, possivelmente errando, o que resultará em um funcionamento incorreto do programa.
Os analistas têm suas próprias reuniões fechadas onde muitas coisas são discutidas sobre o domínio e há um grande compartilhamento do conhecimento. Eles criam um modelo que supostamente contém toda a informação necessária, de uma forma condensada. Os desenvolvedores têm que assimilar tudo, lendo os documentos originais que lhes foram passados. Seria muito mais produtivo se os desenvolvedores pudessem se juntar às reuniões dos analistas e assim alcançar uma visão desobstruída e completa do domínio e do modelo antes de começarem projetar o código.

Uma melhor abordagem é estreitar a relação entre modelagem de domínio e design. O modelo deve ser construído com um olho aberto às considerações do software e o outro no design. Os desenvolvedores devem ser incluídos no processo de modelagem. A ideia principal é escolher um modelo que possa apropriadamente ser expresso no software, de modo que o processo do design seja direto e baseado no modelo. Firmemente relacionar o código a um modelo subjacente dá significação ao código e torna o modelo relevante.

Envolver os desenvolvedores é importante, pois dá a certeza de que o modelo pode ser implementado no software. Se existe algo de errado, é identificado e o problema pode facilmente ser corrigido.
Aqueles que escrevem o código devem conhecer o modelo muito bem e devem se sentir responsáveis pela sua integridade, compreendendo que a alteração do código implicará numa mudança do modelo. Entretanto, eles irão refatorar o código ao ponto de não expressar mais o modelo original. Se o analista for separado do processo de implementação, logo perderá o discernimento sobre as limitações introduzidas pelos desenvolvedores. O resultado é um modelo que não seja prático.
Toda pessoa técnica que contribui para o modelo deve gastar algum tempo analisando o código, qualquer que seja o papel primordial que ele ou ela desempenhe no projeto. Alguém responsável por mudar o código deve aprender a expressar o modelo através do código. Cada desenvolvedor deve estar envolvido em algum nível da discussão sobre o modelo e ter o contato com peritos do domínio. Aqueles que contribuem de maneiras diferentes devem, conscientemente, engajar aqueles que fazem o código, em uma troca dinâmica de ideias do modelo através da Linguagem Ubíqua.

Se o design ou alguma parte central dele não estiverem relacionados ao modelo do domínio, ele será de pouco valor e a exatidão do software será suspeita. Ao mesmo tempo, complexos mapeamentos entre modelos e funções do design são difíceis de compreender e, na prática, impossíveis de serem mantidos com as mudanças no design. O ideal é dividir a análise e o design de modo que a perspicácia adquirida em cada uma dessas atividades não prejudique ambas.

Projete uma parcela do sistema de software de forma que reflita o modelo do domínio de uma maneira direta, para que a transição seja óbvia. Revise o modelo e modifique-o para ser implementado mais naturalmente no software, mesmo quando você procura abstrair uma introspecção mais profunda do domínio. Procure um único modelo que sirva a essas finalidades, apoiando sempre uma fluência na Linguagem Ubíqua.
Extraia do modelo a terminologia utilizada no design e a atribuição básica de responsabilidades. O código se tornará uma expressão do modelo, de modo que a modificação no código possa ser uma mudança do modelo. O seu efeito deve refletir corretamente nas demais atividades do projeto.

Acoplar firmemente a implementação a um modelo geralmente requer ferramentas de desenvolvimento de software e linguagens de programação que suportem um paradigma de modelagem, tal qual a programação orientada a objeto.

A programação orientada a objeto é apropriada para o modelo de implementação porque ambos são baseados no mesmo paradigma. A programação orientada a objetos fornece classes dos objetos e associações dessas classes, das instâncias do objeto e a relação entre eles. As linguagens OOP fazem o possível para criar mapeamentos diretos entre os objetos do modelo e seus relacionamentos com suas contrapartes na programação.
 
Linguagens procedurais oferecem suporte limitado para model-driven design. Tais linguagens não oferecem as construções necessárias para implementar os principais componentes de um modelo. Alguns dizem que OOP pode ser feita com uma linguagem procedural como C, e de fato, algumas das funcionalidades podem ser reproduzidas assim. Os objetos podem ser simulados como estruturas de dados. Tais estruturas não contêm o comportamento do objeto e isso tem que ser adicionado separadamente através de funções. O significado desses dados existe apenas na mente do desenvolvedor, pois o código em si não é autoexplicativo. Um programa escrito em uma linguagem procedural geralmente é descrito como um conjunto de funções, uma chamando a outra, trabalhando juntas para alcançar determinado resultado. Tal programa não pode facilmente encapsular conexões conceituais, fazendo com que o mapeamento entre domínio e código seja difícil de ser conseguido.
 
Alguns domínios específicos, como a matemática, podem ser facilmente modelados e implementados usando a programação procedural, pois muitas teorias matemáticas, por serem essencialmente cálculos, são abordadas simplesmente utilizando-se chamadas a funções e estruturas de dados. Os domínios mais complexos não são apenas um conjunto de conceitos abstratos envolvendo cálculos e não podem ser reduzidos a um conjunto de algoritmos, de modo que as linguagens procedurais ficam aquém da tarefa de expressar os respectivos modelos. Por essa razão, não é recomendável usar a programação procedural para o model-driven design.
